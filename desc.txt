stack-based

1 register -> x
|> push x to stack
<| get value from stack in x / reach finality if stack is empty
+ add 1 to x
- subtract 1 from x 
?1:2 1 if x is 0 else 2





bracket only valid chars -> ()[]{}<|>
var names -> valid bracket nestings only eg: (), (()), (()()), (()(()))
(x)[y] set var x to y
(x)<y|z> if x != 0 then y else z
<x> get value of x
(x){y}[z] define function x with y as argument and z as body 
(x){y} call function x with y as argument 